2015/07/24 初回
2015/08/07 go11.c, go12.c go13.c go14.c を追加
           go06.c, go07.c, go08.c, go09.c, go10.c で
           white_area--; を white_area++; に修正
           go10.c UCTで連続passはplayoutを呼ぶ
2015/08/10 go15.c を追加
           go08.c 〜 go14.c ucb = 10000 + rand(); がまれに
           マイナスになるのを修正
           go10.c 〜 go14.c  #define _CRT_SECURE_NO_WARNINGS 追加。
           sprintfのVC++でのエラー対策
2015/08/18 go15.c にGTPの "undo" を追加。goguiで手を戻したときでも
           時間制御が10分に戻らないように。
           go10.c にも時間制御と"undo" を追加
2016/11/07 go10.c 〜 go15.c 19路盤で"play b p3"がpassになるのを修正


電通大のでの講習用サンプルプログラム集
山下 宏

各ディレクトリにソースとコンパイル用ファイルが入ってます

01/go01.c

を実行するには Linux では

$ make
$ ./go01

VC++では go01.dsw をダブルクリックして「ビルド」「実行」を選んでください。





8月1日
ルールどおりに打つ

8月8日
UCT探索の実装

9月12日
ミニ大会

持ち時間10分切れ負け、中国ルール、コミ6.5目、で行います。
3コウなどの同形反復は引き分けとします。



01/go01.c * 碁盤の表示
02/go02.c * ルールの実装
03/go03.c * ランダムに打つ
04/go04.c   playout関数
05/go05.c * 地合判定
06/go06.c   原始モンテカルロ囲碁
07/go07.c   原始モンテカルロ囲碁をNegaMax形式で
08/go08.c   UCTで探索
09/go09.c   UCTと原始モンテカルロの対戦
10/go10.c   GTP対応。3x3パターン、PW
11/go11.c   RAVE
12/go12.c   ハッシュ法
13/go13.c   地になる確率を表示
14/go14.c   Criticality
15/go15.c   10分切れ負けで打ち切るように


* のついているソースには意図的にバグが入っています。
正しいサンプルは fixed の下にあります。



01/go01.c

碁盤の表示します。
ただし、少し間違って表示されます。
間違いは1箇所で、print_board() 関数の中にあります。

碁盤の表示
  データ構造
    9路盤は9x9。
    board[9][9]   が直感的
    board[11][11] 盤外も含む
    board[y*11+x] の一次元配列で
    黒石は1、白石は2、盤外は3で表す

  9x10で表示されるのを修正して、実行してもらう
  石を配置。
  ソースに石を配置して、正しく表示されるのを確認

  ＡＢＣＤＥＦＧＨＪ
１○●●┬●┬┬┬┐  黒：大橋5段
２○○●●┼●○┼┤  白：Zen
３○┼○●○○●●┤  コミ 7目
４├○○○●●●┼┤  白、Zenの2目勝ち
５├┼┼○●○●┼┤
６├┼○┼○○●┼┤  2012年3月17日対局
７├┼┼┼○●●┼┤  大橋5段が公式に打って
８├┼┼┼○○●┼┤  9路で唯一負けた碁
９└┴┴┴┴○●┴┘



02/go02.c

碁盤に石を置きます。
相手の石が取られること、コウになる場合はエラーとなることを確認します。
最初の状態では石を取らないバグがあります。
バグは1箇所で、put_stone() 関数の中にあります。

main() のコメントを2行づつ外してください。
1回目は右上の黒6子を取ります。
2回目は左下の白を1子取ってコウになるのを確認します。
3回目は白はすぐに左下を取り返しますがコウでエラーを確認します。
4回目は右下の黒を1子取りますがコウにならないのを確認します。

    1 2 3 4 5 6 7 8 9
 1 ┌┬┬┬┬○┬┬┐
 2 ├┼┼┼○●○○○
 3 ├┼┼┼○●●●●
 4 ├┼┼┼┼○●○○
 5 ├┼┼┼┼┼┼┼┤
 6 ├●○┼┼┼┼┼┤
 7 ●○┼○┼┼┼┼┤
 8 ├●○┼○○●●┤
 9 └┴┴┴○●┴○●



白が☆が打ったときに、黒が「囲まれた」ことを判定
  ＡＢＣＤＥＦＧＨＪ    ＡＢＣＤＥＦＧＨＪ
１┌┬┬┬┬○┬┬┐  １┌┬┬┬┬○┬┬┐
２├┼┼┼○●○○○  ２├┼┼┼○●○○○
３├┼┼┼○●●●●  ３├┼┼┼○●●●●
４├┼┼┼┼○●○○  ４├┼┼┼┼○●○○
５├┼┼┼┼┼┼┼┤  ５├┼┼┼┼┼☆┼┤
６├┼┼┼┼┼┼┼┤  ６├┼┼┼┼┼┼┼┤
７├┼┼┼┼┼┼┼┤  ７├┼┼┼┼┼┼┼┤
８├┼┼┼┼┼┼┼┤  ８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘  ９└┴┴┴┴┴┴┴┘




石を消す関数

石を消す関数である。
消す位置から4方向を調べて同じ色の石がある場合はさらにその位置に対して
自分自身を呼んで調べる。
これは再帰関数と呼ばれるもので、慣れるまで理解しにくい。
無限に関数を呼び続けそうだが、この場合、盤上から石が消えていくことで
必ず終了する。

たとえば図で、C5の☆の位置に白が置かれたとする。
中央の黒は完全に囲まれているので取られる。関数の流れは以下のようになる。

    初期図           1             2             3
  ＡＢＣＤＥ    ＡＢＣＤＥ    ＡＢＣＤＥ    ＡＢＣＤＥ 
１┌○┬┬┐  １┌○┬┬┐  １┌○┬┬┐  １┌○┬┬┐ 
２○●○○○  ２○●○○○  ２○●○○○  ２○●○○○ 
３○●●●●  ３○●●●●  ３○●┼●●  ３○●┼┼● 
４├○●○○  ４├○┼○○  ４├○┼○○  ４├○┼○○ 
５└┴☆┴┘  ５└┴○┴┘  ５└┴○┴┘  ５└┴○┴┘ 

       4             5            6
  ＡＢＣＤＥ    ＡＢＣＤＥ    ＡＢＣＤＥ
１┌○┬┬┐  １┌○┬┬┐  １┌○┬┬┐
２○●○○○  ２○●○○○  ２○┼○○○
３○●┼┼┤  ３○┼┼┼┤  ３○┼┼┼┤
４├○┼○○  ４├○┼○○  ４├○┼○○
５└┴○┴┘  ５└┴○┴┘  ５└┴○┴┘
再帰で石を消す



1. まずC4の位置から調べ始める。C4の石を消した後、4方向を
  D4,B4,C5,C3の順に調べる。(右、左、下、上の順で調べる)
  この場合、C3が●なのでC3を次の位置にして自分自身を呼ぶ。
2. C3ではC3の石を消した後、D3,B3,C4,C2の順に調べる。
  最初のD3が●なのでD3を次の位置にして自分自身を呼ぶ。
3. D3ではD3を消した後、E3,C3,D4,D2を調べる。最初のE3が●なのでE3を呼ぶ。
4. E3では4方向に●がなくなったので、3. に戻る。3. でも4方向に●がないので 2. に戻りB3を見つける。
5. B3を消してB2を見つけて呼ぶ。
6. B2を消した後、どんどん関数を戻っていき、1. まで戻って終了する。


囲碁のルールを実装
  囲めば取れる
  黒石を置く
    ４方向を調べる
  石を取る関数の説明
    再帰関数
    詳しく
      関数のコピーが作られるイメージ
      ホワイトボードも使いたい
  ダメの数を数える関数
  石を置く関数の説明
  コウ
    石を1個取った
    打った石のダメが1
    打った石は大きさ1



石を置く関数である．ただしエラーのときは0 以外を返し何もしない．
まずパスの場合はコウを初期化して戻る．石を置く場所の4 方向を調べて，
そこにある石の色と石数，ダメ数を調べる．相手の石が取れる場合はコウの
可能性があるので位置を覚えておく．味方の石があってダメ2 以上なら眼の可
能性がある．自殺手，コウ，眼をつぶす場合はルール違反としてエラー値を
返す．眼をつぶす手は実際にはルール違反ではないが，モンテカルロ法の特
徴としてルール違反とする．すでに石がある場合は，ありえないが念のため
調べている．


コウになる例
  ＡＢＣＤＥＦＧＨＪ  ＡＢＣＤＥＦＧＨＪ
１┌┬┬┬┬┬┬┬┐１┌┬┬┬┬┬┬┬┐
２├┼┼┼┼┼┼┼┤２├┼┼┼┼┼┼┼┤
３├┼┼┼┼┼┼┼┤３├┼┼┼┼┼┼┼┤
４├┼┼┼●○┼┼┤４├┼┼┼●○┼┼┤
５├┼┼●○┼○┼┤５├┼┼●┼★○┼┤
６├┼┼┼●○┼┼┤６├┼┼┼●○┼┼┤
７├┼┼┼┼┼┼┼┤７├┼┼┼┼┼┼┼┤
８├┼┼┼┼┼┼┼┤８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘９└┴┴┴┴┴┴┴┘

  ＡＢＣＤＥＦＧＨＪ  ＡＢＣＤＥＦＧＨＪ
１○┬○┬┬┬┬┬┐１┌★○┬┬┬┬┬┐
２●○┼┼┼┼┼┼┤２●○┼┼┼┼┼┼┤
３●┼┼┼┼┼┼┼┤３●┼┼┼┼┼┼┼┤
４├┼┼┼┼┼┼┼┤４├┼┼┼┼┼┼┼┤
５├┼┼┼┼┼┼┼┤５├┼┼┼┼┼┼┼┤
６├┼┼┼┼┼┼┼┤６├┼┼┼┼┼┼┼┤
７├┼┼┼┼┼┼┼┤７├┼┼┼┼┼┼┼┤
８├┼┼┼┼┼┼┼┤８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘９└┴┴┴┴┴┴┴┘


コウに似てるがコウではない例

2子取っている。
  ＡＢＣＤＥＦＧＨＪ  ＡＢＣＤＥＦＧＨＪ
１┌┬┬┬┬┬┬┬┐１┌┬┬┬┬┬┬┬┐
２├┼┼┼┼┼┼┼┤２├┼┼┼┼┼┼┼┤
３├┼┼┼┼┼┼┼┤３├┼┼┼┼┼┼┼┤
４├┼┼●●○┼┼┤４├┼┼●●○┼┼┤
５├┼●○○┼○┼┤５├┼●┼┼★○┼┤
６├┼┼●●○┼┼┤６├┼┼●●○┼┼┤
７├┼┼┼┼┼┼┼┤７├┼┼┼┼┼┼┼┤
８├┼┼┼┼┼┼┼┤８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘９└┴┴┴┴┴┴┴┘

1子取ったが2子取られる
  ＡＢＣＤＥＦＧＨＪ  ＡＢＣＤＥＦＧＨＪ
１┌┬┬┬┬┬┬┬┐１┌┬┬┬┬┬┬┬┐
２├┼┼┼┼┼┼┼┤２├┼┼┼┼┼┼┼┤
３├┼┼┼┼┼┼┼┤３├┼┼┼┼┼┼┼┤
４├┼┼●●○┼┼┤４├┼┼●●○┼┼┤
５├┼●○┼●○┼┤５├┼●○☆┼○┼┤
６├┼┼●●○┼┼┤６├┼┼●●○┼┼┤
７├┼┼┼┼┼┼┼┤７├┼┼┼┼┼┼┼┤
８├┼┼┼┼┼┼┼┤８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘９└┴┴┴┴┴┴┴┘

実はこの条件でコウが判定できるか、というのは難しい。

  ＡＢＣＤＥＦＧＨＪ
１┌┬┬┬┬┬┬┬┐
２├┼┼┼┼┼┼┼┤ 1子を取ったあとに、単独の石が
３├┼┼┼┼┼┼┼┤ 2子以上取られる、左のような
４├┼┼┼●○┼┼┤ ケースも考えられる。
５├┼┼●┼★○┼┤
６├┼┼○●○┼┼┤ ただ、この形を中央の白1子を
７├┼┼┼○┼┼┼┤ 取って、作るのは無理。
８├┼┼┼┼┼┼┼┤
９└┴┴┴┴┴┴┴┘

長年この判定ルーチンで例外は起きてないので問題ない。
経験から。



  ダメが0になっても石が取られないのを修正してもらう
  石がある配置から2,3手打って石が取られるのを確認




03/go03.c

ランダムに石を打つ思考ルーチンを作成します。


ランダムで石を置く思考ルーチンの作成

追加するデータ構造

#define MAX_MOVES 1000
int record[MAX_MOVES];
int moves = 0;

追加する関数
// 空白の場所を1箇所乱数で返す
int get_empty_z()
// 実際に打ってみる。100回試してダメならパスする
int play_one_move(int color)


  rand()関数を使う
  
  x = rand() % 9
  y = rand() % 9
  (x,y)が空白なら着手候補に
  着手がエラーでなら最初から

  白黒交互に打って対戦
    無限に続くのを確認
  石を置く関数で「眼」を禁止に
    正しく終了するのを確認

終わらない原因は2つあります
  「眼」を自分で埋めて自爆してしまう
  
//srand( (unsigned)time( NULL ) );
をコメントを外すと毎回違った乱数を生成




go04.c

playoutを行う関数
  前回のランダム思考ルーチンそのもの

const int FILL_EYE_ERR = 1;
const int FILL_EYE_OK  = 0;
int put_stone(int tz, int color, int fill_eye_err)
を追加

playout() 関数を追加
空白を乱数で選ぶ方法が前回から少し変わっています。
最初に空白の位置を全部調べて一個ずつ打てるか試します。



go05.c

count_score() 関数を追加
komi = 6.5 を追加

playoutの最終局面の勝敗判定をします。

黒の陣地=55 (石数=45,地=10)
白の陣地=26 (石数=22,地= 4)

合計 黒の+29目、コミを含めても黒の勝ち

を返します。

  ＡＢＣＤＥＦＧＨＪ
１○○○┬○┬○●●
２○○┼○┼○○○●
３○○○○○○○○●
４○○○●●●●●●
５●●●●●●┼●┤
６●●●┼●●●●●
７●┼●●●┼●┼●
８├●●●●●●●┤
９●●┴●┴●●●●

地を数える関数
  playoutでPASS、PASSの局面を想定
    すべての石は活きている、とする
    空白の場所は必ず同じ色で囲まれている
    セキも認識可能
  盤上の石の数＋自分の石で囲まれた地の数を数える
  コミを含めて黒が勝っていれば1を、負けてれば0を返す
    白番なら白が勝っていれば0を、負けていれば -1 を返す
    黒白、どちらでも勝ちなら値が大きい
    後に黒番、白番を意識せずに書くのに役に立つ

  1回playoutをして、正しく勝敗判定できているかを確認
  黒地を白地と計算するバグを修正



go06.c

primitive_monte_calro() 関数を追加

原始モンテカルロ囲碁の作成
  着手可能な場所に30回plyaoutを行う
  一番勝率が高い手を打つ
    黒番では最大の勝率を選ぶ
    白番では最大の勝率を選ぶ


go07.c

primitive_monte_calro() 関数での黒番と白番の場合分けをなくす
playout() 関数は、黒番ではそのまま、白番では符号を反転させた値を返す
  優勢な方が手番に関わらず、常に大きい値
    黒番 黒勝ち +1
         黒負け  0
    白番 白勝ち  0
         白負け -1

count_score() 関数に1行追加
  if ( turn_color == 2 ) win = -win; 
  count_score(turn_color) には playoutを開始した手番を渡す

  win = -playout(flip_color(color));
    手番を反転させて、符号も反転させる
    こういう形なんだと丸暗記
    このような書き方は「NegaMax形式」と呼ばれゲーム木探索ではよく使われる
  win = -primitive_monte_calro(flip_color(color));
    再帰で自分自身を呼ぶ場合はこうなる


    黒番と白番で2つに分かれるのを一つに

    黒番でも白番でも常に「値が大きいほうが有利」
    winの値は黒番なら +1 か 0、白番なら 0 か -1

    winの値は黒番なら +1 か 0、白番なら 0 か -1
    手番にかかわらず、値が大きいほうが有利
    ゲーム木探索をするときの定番
      NegaMax形式
  playoutの回数を増やして着手が囲碁らしくなるのを確認



go08.c

UCTで探索するプログラムの作成
  追加データ構造
    局面のすべての手の勝率、回数を保持
  ノードを作成する関数
  UCB値が一番高い手を選ぶ関数
    一度も試していない手をまず試す
    UCB値の計算
    1回目だけplayoutを行う
    2回目以降は自分自身を呼ぶ(再帰)
    勝率を更新
  UCTを繰り返す関数




go09.c

UCTと原始モンテカルロを自己対戦させてみる

get_computer_move() 関数
  UCTか原始モンテカルロを呼び、手を返す
print_sgf() 関数
  SGFを表示。囲碁の標準棋譜形式(*.sgf)
  コピペで cgfgoban に貼れる
selfplay() 関数
  黒番なら原始モンテカルロ
  白番ならUCT
  原始モンテカルロは 30 playoutずつ、UCTは全体で1000 playout なら7割近くUCTが勝つ

test_playout() 関数
  playout を1回だけ行って、棋譜をsgfで出力
  main() の中のコメントを外す




go10.c

printf() 関数を prt() 関数に。stderr に出力
send_gtp() 関数。stdoutに出力。他のプログラムと通信。
print_board() 関数を GTPの座標にあわせる
get_char_z() 関数。get81() の座標をGTP用の文字列で返す

pattern3x3[]  3x3のパターン。
expand_pattern3x3() 3x3のパターンを回転、対称で8パターンに展開
match_pattern3x3() 3x3のパターンに一致するか
int dir8[8] = { +1,+WIDTH,-1,-WIDTH,  +1+WIDTH, +WIDTH-1, -1-WIDTH, -WIDTH+1 };

playout() 関数を個々の手の確率の大きさで選ぶように
  A,B,Cが 30,50,20 なら 30%, 50%, 20% の確率で選ぶように
get_prob() その着手の確率値(大きいほど打ちやすい)を設定
  お勧めの改良
    相手の直前の手にくっつけて打つ手の確率を上げる
    盤端に打つ確率を下げる
    3x3パターンマッチングは直前の相手の手の周囲だけに行う

構造体 CHILD に bonus を追加。個々の手の形の良さを示す

get_bonus() いい手にボーナスを与える。
create_node() いい手の順にソートする

UCBの式に形のボーナスを追加。いい手は優先的に探索。
  よさそうな手の値を直接UCBに加算
  Progressive Windeningのソートで使った値をそのまま
  ucb = c->rate + C * sqrt( log((double)pN->child_games_sum) / c->games ) + plus;
Progressive Widening
 すべての手を均等に調べるのではなく、最初のうちはいい形の上位数手しか調べない
 30 playout では上位5手、1000 playoutでは上位20手、など
 pw_num


改良のポイント

playout
  3x3のパターンの追加
  アタリにされた石の周囲に敵石がダメ1なら取る手を打たせる
    データ構造が単純なので大変
  アタリにされた石が逃げる
    同じく大変
  1線に打つ確率を下げる
  石を取らずにアタリに自爆する手を避ける
    大変

Progressive Widening
  3x3のパターンを使ってみる

UCBの式、Progressive Wideningの定数を変えてみる
      const double C = 1;    // depends on program
      const double B0 = 0.1;
      const double B1 = 100;
  int pw_num = (int)(1.0 + log(pN->child_games_sum+1.0) / log(1.8));

UCBの式にRAVEを追加

自己対戦で勝率を調べる
  gogui-twogtp.jar での対戦させ方
  go10同士を100局対戦させる
    java -jar gogui-twogtp.jar -black "c:\dentsu\10\release\go10.exe" -white "c:\dentsu\10\release\go10.exe" -games 100 -size 9 -alternate -sgffile go10test -auto
  go10同士を100局対戦させる。終局判定にGNU Goを使う
    java -jar gogui-twogtp.jar -black "c:\dentsu\10\release\go10.exe" -white "c:\dentsu\10\release\go10.exe" -games 100 -size 9 -alternate -sgffile go10test -auto -referee "c:\go\gnugo\gnugo.exe --mode gtp --chinese-rules"
  結果をhtmlで表示
    java -jar gogui-twogtp.jar -analyze go10test.dat

  GNU Go のWindowsバイナリ
  http://gnugo.baduk.org/



GTPで操作
  GUIの利用
  Linux, Windows
    gogui  (Java)
    http://gogui.sourceforge.net/
    "java -jar gogui.jar" で起動
    「プログラム」「新規プログラム」
      「コマンド」に
        「X:\go1\dentsu\10\Release\go10.exe」
      「ワーキングディレクトリに」に
        「X:\go1\dentsu\10」

  Windows
    cgfgoban 
    http://www.yss-aya.com/cgfgoban_j.html
    「Setting」「GTP Setting」に下記を入力
    「X:\go1\dentsu\10\Release\go10.exe」


GTPでの操作は

genmove b    ... 黒番で手を打て
play w d3    ... 白をD3に置く
name         ... プログラム名を聞く
version      ... バージョンを聞く
clear_board  ... 盤面を初期化する
quit         ... 終了



SGFを再生するソフト
Windows  Kiin Editor  SGFのコピー＆ペーストが可能
http://www.nihonkiin.or.jp/teach/kiin_editor/

他のサンプルなど
http://www.yss-aya.com/book2011/

playoutの手順を確認
  SGFをコピペしてcgfgobanに読ませる

SGFのコピペの仕方
Visual C++のDOSプロンプトの画面をコピーするには
画面左上のアイコンを右クリック
「編集」「範囲指定」で指定してEnter、でコピーされる。

goguiに貼り付けるには
「ファイル」「インポート」「クリップボードからSGF形式読み込み」
cgfgobanには画面上で「Ctrl+V」




go11.c

RAVE
int path[]  UCT + playout の手順
int depth   UCT + playout の手数



go12.c
ハッシュ法
64ビット変数を使っているで
VC++やgcc以外ではコンパイルが通らないかもしれません。


go13.c
地になる確率を表示
playoutが死活を正しく認識できているか


go14.c
Criticality
勝敗を決定する重要な地点が分かる


go15.c
10分で打ち切るサンプルです。
UCTでのみ対応で、原始モンテカルロでは動作しません。

uct_loop = 1000000; と大きな数にして経過時間で打ち切ってます。

残り秒数を12、という定数で割った値を1手の思考時間としています。
残り3分(180秒)なら180/12=15秒考えます。
残り1分を切ったら1手1秒、残り20秒で0.2秒で打ちます。


712行目の get_clock() 関数から count_total_time() までと
play_computer_move()関数の先頭に時間設定が入っています。

この関数は get_computer_move()関数 と add_moves()関数を一緒にしたものです。





＊＊＊＊＊＊＊＊  発展  ＊＊＊＊＊＊＊＊

連のデータ構造
Bitboardによる碁盤の表現

